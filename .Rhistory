Performance ~ Cognitive + Somatic + Selfconfidence
Selfconfidence ~ Cognitive + Somatic
## Fix the variances of Cog and SO at 1
Cognitive ~~ 1*Cognitive
Somatic ~~ 1*Somatic
Cognitive ~~ Somatic"
output1 <- path_model(data = model_out_random, model = model, num_obs = sum(becker09$N))
model_out_random <- extract_model(random_model,
variable_names = c('Cognitive_Performance',
'Somatic_Performance',
'Selfconfidence_Performance',
'Somatic_Cognitive',
'Selfconfidence_Cognitive',
'Selfconfidence_Somatic'))
model <- "## Regression paths
Performance ~ Cognitive + Somatic + Selfconfidence
Selfconfidence ~ Cognitive + Somatic"
output1 <- path_model(data = model_out_random, model = model, num_obs = sum(becker09$N))
summary(output1)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(metaRmat)
library(metafor)
library(corpcor)
library(Matrix)
library(matrixcalc)
becker09 <- read.csv(paste0(system.file('raw_data', package = 'metaRmat'), '/Becker09.csv'))
becker09 <- na.omit(becker09) # ommiting studies with NA
becker09
becker09_list <- df_to_corr(becker09,
variables = c('Cognitive_Performance',
'Somatic_Performance',
'Selfconfidence_Performance',
'Somatic_Cognitive',
'Selfconfidence_Cognitive',
'Selfconfidence_Somatic'),
ID = 'ID')
# vectorize the correlation matrix
sm2vec(becker09_list$`3`)
# Computations needed to obtain the weighted average by n
Rw1 <- lapply(becker09_list, sm2vec)  # vectorize
Rw2 <- mapply("*",Rw1, becker09$N, SIMPLIFY = FALSE)  # multiply by n
Rw3 <- Reduce("+", Rw2)
nS <- Reduce('+', becker09$N)   # sum all n
Rw4 <- Rw3/nS
# results on the chapter
round(Rw4, 3)
# Compuations needed to obtain the weighted average by n
round(olkin_siotani(becker09_list, becker09$N, type = "weighted")[[2]], 3)
# compute var-cov for each study
VC_s <- olkin_siotani(becker09_list, becker09$N, type = 'simple')
# extract the diagonal (variance) from each
V_s <- lapply(VC_s, diag)
# vectorize corr matrices
rr <- lapply(becker09_list,  sm2vec)  # vectorize
# select proper elements of each list
fun_list <- function(lst, n){
sapply(lst, `[`, n)
}
# now six separated univariate metas under common-effects
a <- 1:length(rr[[1]])
res <- numeric(length = length(a))
for (i in seq_along(a)) {
res[i] <-  metafor::rma(yi = fun_list(rr, i), vi = fun_list(V_s, i), method = "FE")$b
}
# common-effects results
round(res, 3)
res2 <- numeric(length = length(a))
for (i in seq_along(a)) {
res2[i] <-  metafor::rma(yi = fun_list(rr, i), vi = fun_list(V_s, i))$b
}
# randon-effects results
round(res2, 3)
input_metafor <- prep_data(becker09, becker09$N, type = 'weighted', missing = FALSE,
variable_names = c('Cognitive_Performance', 'Somatic_Performance',
'Selfconfidence_Performance',
'Somatic_Cognitive',
'Selfconfidence_Cognitive',
'Selfconfidence_Somatic'),
ID = 'ID')
# Fitting the model
random_model <- fit_model(data = input_metafor, effect_size = 'yi',
var_cor = 'V', moderators = ~ -1 + factor(outcome),
random_params = ~ factor(outcome) | factor(study))
# result
round(vec2sm(random_model$b, diag = FALSE), 3) # random effect estimate
# Fist we fit the model
common_model <- fit_model(data = input_metafor, effect_size = 'yi',
var_cor = 'V', moderators = ~ -1 + factor(outcome),
random_params = NULL)
# result
round(vec2sm(common_model$b, diag = FALSE), 3) # common effect estimate
# covariance of random-effects means
round(random_model$vb, 4) # random effect Cov
round(common_model$vb, 4) # fixed effect COV
# I2
res3 <- numeric(length = length(a))
for (i in seq_along(a)) {
res3[i] <- 100 * (vcov(random_model)[i,i] - vcov(common_model)[i,i]) / vcov(random_model)[i,i]
}
round(res3)
# Q
common_model$QE
# df
common_model$df
#------------------
# tau matrix
#------------------
mdiag <-1
rho <-  vec2sm(random_model$rho, diag = FALSE)
diag(rho) <- mdiag
tdiag <- diag(sqrt(random_model$tau2))
taumat <- tdiag %*% rho %*% tdiag
round(taumat, 3)
round(cov2cor(taumat),3)
# T matrix
round(cov2cor(taumat),3)
# Qb
round(random_model$QM, 2)
# T matrix
round(random_model$zval[1], 2) # z value
round(random_model$pval[1], 2) # p value
model_out_random <- extract_model(random_model,
variable_names = c('Cognitive_Performance',
'Somatic_Performance',
'Selfconfidence_Performance',
'Somatic_Cognitive',
'Selfconfidence_Cognitive',
'Selfconfidence_Somatic'))
model <- "## Regression paths
Performance ~ Cognitive + Somatic + Selfconfidence
Selfconfidence ~ Cognitive + Somatic"
output1 <- path_model(data = model_out_random, model = model, num_obs = sum(becker09$N))
summary(output1)
Br <- model_out_random$beta_matrix
Br_2 <- Br[-1, -1]
Rxx_2 <- Br_2[-3, -3]
Rxy_2 <- Br_2[3, 1:2]
B_2 <- solve(Rxx_2) %*% Rxy_2
# variance explained for self-confidence
R_2 <- t(B_2) %*% Rxy_2
round(100*R_2)
Br <- vec2sm(random_model$b, diag = FALSE)
diag(Br) <- 1
Rxx <- Br[-1, -1]
Rxy <- Br[1, 2:4]
B <- solve(Rxx) %*% Rxy
# variance explained for sport performance
R2 <- t(B) %*% Rxy
round(100*R2)
# partial corr matrix
round(cor2pcor(model_out_random$beta_matrix),3)[4,1]
# var-cov matrix of partials
Psy <- random_model$vb
var_p <- var_path(model_out_random$beta_matrix, Psy, type = 'pcor')
round(sqrt(diag(var_p)),3)
#---------------------------------------------------------------------
# Create a data set with 8 complete studies
#---------------------------------------------------------------------
R <-  becker09_list
n <- becker09$N
#------------------------------------------------------------------
# first replace NA by zeros
RR <- R                           # redifine list
PR <- lapply(RR, cor2pcor)
pr <- unlist(lapply(PR, '[[', 4))
var_pr <- (1-pr^2)^2 / (n - 3 -1)
round(rma.uni(pr, var_pr)$b, 3)
round(rma.uni(pr, var_pr)$se, 4)
library(devtools)
install_github("UCL/mimix")
install_github("UCL/mimix")
install_github("UCL/mimix")
install_github("UCL/mimix")
install_github("UCL/RefBasedMI")
install_github("UCL/RefBasedMI")
remove.packages(fansi)
library(devtools)
if(!require(devtools)) install.packages('devtools')
library(devtools)
install_github("UCL/RefBasedMI")
source('C:/ado/ian/myRmimix/test/Ian installation.R', echo=TRUE)
install_github("UCL/RefBasedMI")
install_github("UCL/RefBasedMI")
install_github("UCL/RefBasedMI")
library(norm2)
library(mimix)
library(mice)
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = ridge, burnin = 1000)
help(mimix)
mimix()
Rmimix()
RefBasedMI()
asthma
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = ridge, burnin = 1000)
impJ2Rridge <- mimix(data = asthma, covar = c(base), depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = "J2R", reference = 2,
delta = c(-1, 0, 0, 0), M = 5, seed = 101, prior = "ridge")
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
acuCausal <- mimix(data = acupuncture, covar = c(head_base), depvar = head,
treatvar = treat, idvar = id, timevar = time, method = "Causal",
reference = 1, K0 = 1, K1 = 0.5, M = 5, seed = 54321)
acufit <- with(as.mids(subset(impCausalref, time == 12)),
lm(head ~ treat + head_base + sex))
summary(pool(acufit))
acufit <- with(as.mids(subset(acuCausal, time == 12)),
lm(head ~ treat + head_base + sex))
summary(pool(acufit))
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = ridge, burnin = 1000)
# J2R analysis with control as reference
asthmaJ2R <- mimix(data = asthma, covar = base, depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = ridge, burnin = 1000)
asthmaJ2R <- mimix(data = asthma, covar = base, depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = 'ridge', burnin = 1000)
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = 'ridge', burnin = 1000)
# J2R analysis with control as reference
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = ridge, burnin = 1000)
impJ2Rridge <- mimix(data = asthma, covar = c(base), depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = "J2R", reference = 2,
delta = c(-1, 0, 0, 0), M = 5, seed = 101, prior = "ridge")
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
antidepressant
head(antidepressant)
antidepressant=antidepressant
View(antidepressant)
head(antidepressant)
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
which(mimix)
version(mimix)
library(RefBasedMI)
asthmaJ2R <- mimix(data = asthma, covar = 'base', depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = 'ridge', burnin = 1000)
asthmafit <- with(data = as.mids(asthmaJ2R), lm(fev.12 ~ treat + base))
summary(pool(asthmafit))
View(asthmaJ2R)
View(asthmaJ2R)
asthmafit <- with(data = as.mids(subset(asthmaJ2R, time==12), lm(fev.12 ~ treat + base))
)
asthmafit <- with(data = as.mids(subset(asthmaJ2R, time==12)), lm(fev.12 ~ treat + base))
asthmafit <- with(data = as.mids(subset(asthmaJ2R, time==12)), lm(fev ~ treat + base))
summary(pool(asthmafit))
impJ2Rridge <- mimix(data = asthma, covar = c(base), depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = "J2R", reference = 2,
delta = c(-1, 0, 0, 0), M = 5, seed = 101, prior = "ridge")
asthmaJ2R <- mimix(data = asthma, covar = base, depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = 'J2R', reference = 2, M = 5, seed = 101,
prior = 'ridge', burnin = 1000)
asthmadelta <- mimix(data = asthma, covar = base, depvar = fev, treatvar = treat,
idvar = id, timevar = time, method = "J2R", reference = 2,
delta = c(-1, 0, 0, 0), M = 5, seed = 101, prior = "ridge")
acuCausal <- mimix(data = acupuncture, covar = head_base, depvar = head,
treatvar = treat, idvar = id, timevar = time, method = "Causal",
reference = 1, K0 = 1, K1 = 0.5, M = 5, seed = 54321)
source('C:/ado/ian/myRmimix/paper/examples.R', echo=TRUE)
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
help(mimix)
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, method = "CIR", reference = 2,
M = 5, seed = 54321)
antidepIndiv <- mimix(data = antidepressant, covar = c(basval),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
antidepIndiv <- mimix(data = antidepressant, covar = basval,
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, methodvar = methodcol, referencevar = referencecol,
M = 5, seed = 54321)
### Sample data: acupuncture trial
# Causal model: treatment effect halves every 1 time unit
# after treatment discontinuation
acuCausal <- mimix(data = acupuncture, covar = head_base, depvar = head,
treatvar = treat, idvar = id, timevar = time, method = "Causal",
reference = 1, K0 = 1, K1 = 0.5, M = 5, seed = 54321)
# Analysis
acufit <- with(as.mids(subset(acuCausal, time == 12)),
lm(head ~ treat + head_base + sex))
summary(pool(acufit))
View(acufit)
install_github("UCL/RefBasedMI")
install_github("UCL/mimix")
install_github("UCL/Rmimix")
help("RefBasedMI")
help(RefBasedMI)
help("mimix")
source("C:\\ado\\ian\\Rmimix\\R\\Runmimix.R")
source("C:\\ado\\ian\\Rmimix\\R\\proprocess.R")
source("C:\\ado\\ian\\Rmimix\\R\\utilities.R")
help("mimix")
help("mimix")
cat("C:\\ado\\ian\\Rmimix\\R\\Runmimix.R")
cat(C:\\ado\\ian\\Rmimix\\R\\Runmimix.R)
install_github("UCL/RefBasedMI")
help("mimix")
install_github("UCL/RefBasedMI")
install_github("UCL/RefBasedMI")
help("mimix")
help("RefBasedMI")
help("RefBasedMI::mimix")
library(RefBasedMI)
help("RefBasedMI::mimix")
help("RefBasedMI")
help("mimix")
help("RefBasedMI")
help("RefBasedMI::mimix")
help(RefBasedMI::mimix)
source('C:/ado/ian/myRmimix/paper/examples.R', echo=TRUE)
antidepIndiv <- mimix(data = antidepressant, covar = c(basval, PATIENT.SEX),
depvar = HAMD17.TOTAL, treatvar = TREATMENT.NAME, idvar = PATIENT.NUMBER,
timevar = VISIT.NUMBER, method = "CIR", reference = 2,
M = 5, seed = 54321)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
ind_effect
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
source('~//Home/Design/PRaCTical/simpaper/Kim/test script for smallest effect function.R', echo=TRUE)
which.min(1,2,3)
which.min(c(1,2,3))
which.min(c(1,1,3))
which.min(c(2,1,3))
source("C:/ado/ian/PRACTical/1 PRaCTical_functions22072021.R")
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
setwd("C:/ado/ian/PRACTical")
# Ian's variant of Kim's file to run one rep
# run this with N=100 and seed=5 to demonstrate that method C mis-handles perfect prediction
#   as a treatment with 0 deaths is never selected as best
# N=1000 and seed=2 is a good example of B3 beating C
source('1 PRaCTical_functions22072021i.R')
### SETTINGS
set.seed(5)
no_treatment=10
N=1000 # total number of patients
# treatment patterns
pattern1<-c(2,3,5,8,10)
pattern2<-1:7
pattern3<-c(1,2,4,9,10)
pattern4<-c(1,2,3,5,6,8,10)
pattern5<-c(1,2,3,4,6,7)
pattern6<-2:10
pattern7<-1:10
pattern8<-3:10
patternV<-list(pattern1, pattern2, pattern3, pattern4, pattern5, pattern6, pattern7, pattern8)
### END OF SETTINGS (MOSTLY)
pattern<-patternV
# treatment effect parameters
# scenario 1
alpha_1<-find_phi(0.2, alpha=0)
phi_1<-find_phi(seq(0.1, 0.3, length.out = no_treatment), alpha=alpha_1)
res_rate1<-res_probability(phi_1,alpha_1)
phi_v=phi_1 # true parameters of treatment effect
pattern=patternV # personalized randomization lists
response_prob_V=res_rate1 # response probability
prob_pattern= c(0.2, 0.2, rep(0.1, 6)) # prevelance rate of patterns
R=5 # number of trial replications
# ----- the following is copied from 2 simulation_replication.R ----- #
no_pattern<-length(pattern) # number of randomization lists
no_comparison<-sapply(1:no_pattern, function(i){length(pattern[[i]])-1})
# for each randomization list, the number of pairwise comparisons fixing a reference treatment.
no_treatment<-length(phi_v) # number of treatments
res_probability_all<-matrix(rep(response_prob_V, no_pattern), ncol = no_treatment, byrow = T)
colnames(res_probability_all)<-sapply(1:no_treatment, function(i){paste0("treatment_", i)} )
rownames(res_probability_all)<-sapply(1:no_pattern, function(i){paste0("alpha_", i)} )
# response rate: row= pattern, column=treatment. All rows have same values for this scenario
# each person has prob_pattern to be allocated to one of the treatment patterns
assigned_pattern<-t(rmultinom(N, size=1, prob_pattern))
colnames(assigned_pattern)<-sapply(1:no_pattern, function(i){paste0("subgroup", i)} )
# number of patients in each subgroup that is defined by the pattern
size_pattern<-apply(assigned_pattern, 2, sum)
lambda<-prob_pattern # true prevalence rate of patterns
true.response.r<-lapply(1:no_pattern,function(i)res_probability_all[i, pattern[[i]]])
# response rates of the treatments in each pattern
true.mean.min<-lapply(1:no_pattern, function(i){
v<-true.response.r[[i]]
c("mean"=mean(v), "min"=min(v)) } )
true.mean.min<-do.call(cbind, true.mean.min)
# compute the mean (and minimum value) of the treatments in each pattern
# will be used for the performance measures about the treatment decisions
No_contrast<-length(unique(unlist(pattern)))
# this is the total number of treatments
# to be used in method C and D as index for the nine treatment contrasts
# ** the following come from the loop of the function, exclude the list of output ** #
Alldata<-sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_all)})
# generate one dataset
# Ian's additions to fit model C
# nma_data<-data.frame(y=unlist(Alldata[1,]),
#                      treatment=factor(unlist(Alldata[2,])),
#                      subgroup=factor(unlist(Alldata[4,])))#patient_subgroup)))
# table(nma_data$subgroup,nma_data$treatment)
# glm<-glm(y~factor(treatment)+factor(subgroup),data=nma_data,family=binomial(logit))
# summary(glm)
feq_t_subgroup<-sapply(1:no_pattern, function(i)table(Alldata[2,][[i]]))
# show how many have been randomized to a treatment arm within a pattern
feq_t<-table(unlist(Alldata[2,]))
# show how many have been randomized to each treatment arm
est_method_C<-fit_onestage_C(Alldata, no_p=no_pattern,   q.val=qnorm(0.975), no_contrast=No_contrast) # use original data
# estimates of treatment contrasts from method C
est_method_D<-fit_robustSE_D(Alldata, no_com=no_comparison, # use duplicated data
no_p=no_pattern,
no_t=no_treatment,
size_p=size_pattern,no_contrast=No_contrast)
# estimates of treatment contrasts from method D
Identify_C=smallest_effect(est_method_C[,1], pat=pattern, no_p=no_pattern)
# for method C
# row 1: the best treatment for each pattern (column)
# row 2: check if the model fails to fit, 1= fail, 0= model is fitted
# when row two=1 a random treatment is drawn for the treatment decision
Identify_D=smallest_effect(est_method_D[,1], pat=pattern, no_p=no_pattern)
# for method D
# row 1: the best treatment for each pattern (column)
# row 2: check if the model fails to fit, 1= fail, 0= model is fitted
# when row two=1 a random treatment is drawn for the treatment decision
method_A_f<-fit_subgroup_A(Alldata, no_p=no_pattern)   # fit each subgroup
# method A: fit a model to each pattern and identify the best treatment
# row 1 and 2 carry the same interpretation as methods C and D
Identify_method_B<-methodB(Alldata, no_p=no_pattern, size_p=size_pattern, pat=pattern)
# method B with different pooling: fit a model to each pattern and identify the best treatment
# list 1 correspond to estimated best decision
# list 2 check if the model fails to fit, 1= fail, 0= model is fitted
# each row within a list corresponds to an approach of pooling
identified_best_t<-rbind(method_A=method_A_f[1,],
method_B1=Identify_method_B[[1]][1,],
method_B2=Identify_method_B[[1]][2,],
method_B3=Identify_method_B[[1]][3,],
method_C=Identify_C[1,],
method_D=Identify_D[1,] )
# combine estimated best treatments from all methods, row= methods, column= pattern
### REST OF PROGRAM DELETED
### IAN'S CODE TO EXPLORE WHAT WE'VE DONE ###
#  tabulate data
nma_data<-data.frame(y=unlist(Alldata[1,]),
treatment=factor(unlist(Alldata[2,])),
subgroup=factor(unlist(Alldata[4,])))#patient_subgroup)))
table(nma_data$y,nma_data$treatment,nma_data$subgroup)
# Model fit for method C:
est_method_C
# -> treatment 4 is the best (most negative)
# Best treatments for each method:
identified_best_t
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
length(c(1,2,4))
c=c(1,2,4)
c
c'*c'
c'*c
''
t(c)*c
t(c)%*%c
c%*%t(c)
d=c%*%t(c)
d
dim(d)
rows(d)
dim(d)[1]
dim(d)[2]
dim(c)[2]
dim(c)[1]
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
dim(d)[1]
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
source("C:/ado/ian/PRACTical/PRACTical_one data replication_ian.R", echo=TRUE)
